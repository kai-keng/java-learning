(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{473:function(t,a,s){"use strict";s.r(a);var r=s(42),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"行为型-命令模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行为型-命令模式"}},[t._v("#")]),t._v(" 行为型-命令模式")]),t._v(" "),s("h2",{attrs:{id:"定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),s("p",[t._v("给一系列不同的命令定义一个接口，再把这些命令分别定义成不同的实现接口的类，在控制器中传入命令接口，通过设置不同的命令，可以在控制器中自由控制需要执行的命令，达到解耦的目的，非常类似于策略模式。")]),t._v(" "),s("h2",{attrs:{id:"与策略模式的不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与策略模式的不同"}},[t._v("#")]),t._v(" 与策略模式的不同")]),t._v(" "),s("p",[t._v("浅显的来看，策略模式是封装易变化的部分，通过不同情况替换不同的策略，都是为了达到同一个目的，命令模式则是封装不同的命令，执行不同的命令达到不同的目的。")]),t._v(" "),s("h2",{attrs:{id:"实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),s("p",[t._v("与策略模式相似")])])}),[],!1,null,null,null);a.default=e.exports}}]);