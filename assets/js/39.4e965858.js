(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{467:function(t,e,v){"use strict";v.r(e);var r=v(42),_=Object(r.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"queue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[t._v("#")]),t._v(" Queue")]),t._v(" "),v("p",[t._v("队列是一种支持 FIFO（先进先出） 的数据结构，尾部添加、头部删除，跟我们生活中的排队类似。Queue 接口也继承自 Collection 接口，主要实现有LinkedList、PriorityQueue、BlockingQueue等。")]),t._v(" "),v("h2",{attrs:{id:"队列常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#队列常用方法"}},[t._v("#")]),t._v(" 队列常用方法")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法名")]),t._v(" "),v("th",[t._v("方法描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("add")]),t._v(" "),v("td",[t._v("增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常")])]),t._v(" "),v("tr",[v("td",[t._v("remove")]),t._v(" "),v("td",[t._v("移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常")])]),t._v(" "),v("tr",[v("td",[t._v("element")]),t._v(" "),v("td",[t._v("返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常")])]),t._v(" "),v("tr",[v("td",[t._v("offer")]),t._v(" "),v("td",[t._v("添加一个元素并返回true 如果队列已满，则返回false")])]),t._v(" "),v("tr",[v("td",[t._v("poll")]),t._v(" "),v("td",[t._v("移除并返问队列头部的元素 如果队列为空，则返回null")])]),t._v(" "),v("tr",[v("td",[t._v("peek")]),t._v(" "),v("td",[t._v("返回队列头部的元素 如果队列为空，则返回null")])]),t._v(" "),v("tr",[v("td",[t._v("put")]),t._v(" "),v("td",[t._v("添加一个元素 如果队列满，则阻塞")])]),t._v(" "),v("tr",[v("td",[t._v("take")]),t._v(" "),v("td",[t._v("移除并返回队列头部的元素 如果队列为空，则阻塞")])])])]),t._v(" "),v("h2",{attrs:{id:"双端队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双端队列"}},[t._v("#")]),t._v(" 双端队列")]),t._v(" "),v("p",[t._v("普通的队列只可以在队尾添加数据，队头获取数据，但是双端队列两端都可以添加或获取数据，即可以打破先进先出的规则，所以双端队列也可以当做栈使用（后进先出），在 Java 中 实现 Dequeue 接口的均为双端队列。")]),t._v(" "),v("p",[t._v("对应方法：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("Queue 方法")]),t._v(" "),v("th",[t._v("等效Deque方法")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("add(e)")]),t._v(" "),v("td",[t._v("addLast(e)")])]),t._v(" "),v("tr",[v("td",[t._v("offer(e)")]),t._v(" "),v("td",[t._v("offerLast(e)")])]),t._v(" "),v("tr",[v("td",[t._v("remove()")]),t._v(" "),v("td",[t._v("removeFirst()")])]),t._v(" "),v("tr",[v("td",[t._v("poll()")]),t._v(" "),v("td",[t._v("pollFirst()")])]),t._v(" "),v("tr",[v("td",[t._v("element()")]),t._v(" "),v("td",[t._v("getFirst()")])]),t._v(" "),v("tr",[v("td",[t._v("peek()")]),t._v(" "),v("td",[t._v("peekFirst()")])])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("栈方法")]),t._v(" "),v("th",[t._v("等效Deque方法")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("push(e)")]),t._v(" "),v("td",[t._v("addFirst(e)")])]),t._v(" "),v("tr",[v("td",[t._v("pop()")]),t._v(" "),v("td",[t._v("removeFirst()")])]),t._v(" "),v("tr",[v("td",[t._v("peek()")]),t._v(" "),v("td",[t._v("peekFirst()")])])])]),t._v(" "),v("h2",{attrs:{id:"实现介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现介绍"}},[t._v("#")]),t._v(" 实现介绍")]),t._v(" "),v("p",[t._v("LinkedList 请参照"),v("a",{attrs:{href:"https://kai-keng.github.io/java-learning/collection/list.html#linkedlist",target:"_blank",rel:"noopener noreferrer"}},[t._v("LinkedList"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("阻塞队列 PriorityQueue、BlockingQueue 请参照"),v("a",{attrs:{href:"https://kai-keng.github.io/java-learning/multi-thread/thread-util.html#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97",target:"_blank",rel:"noopener noreferrer"}},[t._v("阻塞队列\n"),v("OutboundLink")],1)]),t._v(" "),v("h2",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),v("ol",[v("li",[v("a",{attrs:{href:"https://www.jianshu.com/p/d78a7c982edb",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解Java集合之---Deque"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://www.jianshu.com/p/7a86c56c632b",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java队列（Queue）了解及使用"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=_.exports}}]);