(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{359:function(t,a,s){t.exports=s.p+"assets/img/java-collections.88564728.jpg"},462:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[t._v("#")]),t._v(" 概览")]),t._v(" "),e("h2",{attrs:{id:"集合是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集合是什么"}},[t._v("#")]),t._v(" 集合是什么")]),t._v(" "),e("p",[t._v("集合是JDK提供的在java.util包下一些用于批量存储数据的容器，类似于数组，集合有很多种，不同的集合有不同的特点，可以应用于不同场景。")]),t._v(" "),e("h2",{attrs:{id:"为什么使用集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用集合"}},[t._v("#")]),t._v(" 为什么使用集合")]),t._v(" "),e("p",[t._v("在使用数组批量存储数据的时候限制有很多，比如数组的长度在声明的时候就需要确定，而且一旦声明以后长度都是不可变的，这样并不方便于日常开发的很多场景，但是集合的长度就是可变的，不需要自己去声明长度。且数组只是一个有序的可重复的存储结构，无法应对我们需要存储不可重复数据的情况，或者当我们需要存储键值对这样的数据结构的时候，数组也是无法做到的。反观集合则是种类繁多，可以应对不同场景下的需求，灵活多变。")]),t._v(" "),e("h2",{attrs:{id:"java集合部分概览图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java集合部分概览图"}},[t._v("#")]),t._v(" Java集合部分概览图")]),t._v(" "),e("p",[e("img",{attrs:{src:s(359),alt:"Java集合概览图"}})]),t._v(" "),e("h2",{attrs:{id:"集合分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集合分类"}},[t._v("#")]),t._v(" 集合分类")]),t._v(" "),e("p",[t._v("从上图可以看出，Java集合框架分为 "),e("strong",[t._v("Collection")]),t._v("(集合) 与 "),e("strong",[t._v("Map")]),t._v("(图)，Collection 继承自 Iterable 接口，Collection 下主要有：")]),t._v(" "),e("ul",[e("li",[t._v("List")]),t._v(" "),e("li",[t._v("Set")]),t._v(" "),e("li",[t._v("Queue")])]),t._v(" "),e("p",[t._v("我们日常使用中最多的主要是 List，Set 与 Map，接下来会分别介绍这几个。")])])}),[],!1,null,null,null);a.default=r.exports}}]);